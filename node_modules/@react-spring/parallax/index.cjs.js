'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
var React = require('react');
var web = require('@react-spring/web/index.cjs.js');
var useMemoOne = require('use-memo-one');
var globals = require('@react-spring/shared/globals');
var shared = require('@react-spring/shared');

var ParentContext = React.createContext(null);

function getScrollType(horizontal) {
  return horizontal ? 'scrollLeft' : 'scrollTop';
}

var START_TRANSLATE_3D = 'translate3d(0px,0px,0px)';
var START_TRANSLATE = 'translate(0px,0px)';
var ParallaxLayer = React.memo(React.forwardRef(function (_ref, ref) {
  var _extends2;

  var horizontal = _ref.horizontal,
      _ref$factor = _ref.factor,
      factor = _ref$factor === void 0 ? 1 : _ref$factor,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? 0 : _ref$offset,
      _ref$speed = _ref.speed,
      speed = _ref$speed === void 0 ? 0 : _ref$speed,
      rest = _objectWithoutPropertiesLoose(_ref, ["horizontal", "factor", "offset", "speed"]);

  // Our parent controls our height and position.
  var parent = React.useContext(ParentContext); // This is how we animate.

  var ctrl = useMemoOne.useMemoOne(function () {
    var targetScroll = Math.floor(offset) * parent.space;
    var distance = parent.space * offset + targetScroll * speed;
    return new web.Controller({
      space: parent.space * factor,
      translate: -(parent.current * speed) + distance
    });
  }, []); // Create the layer.

  var layer = useMemoOne.useMemoOne(function () {
    return {
      setPosition: function setPosition(height, scrollTop, immediate) {
        if (immediate === void 0) {
          immediate = false;
        }

        var targetScroll = Math.floor(offset) * height;
        var distance = height * offset + targetScroll * speed;
        ctrl.start({
          translate: -(scrollTop * speed) + distance,
          config: parent.config,
          immediate: immediate
        });
      },
      setHeight: function setHeight(height, immediate) {
        if (immediate === void 0) {
          immediate = false;
        }

        ctrl.start({
          space: height * factor,
          config: parent.config,
          immediate: immediate
        });
      }
    };
  }, []);
  React.useImperativeHandle(ref, function () {
    return layer;
  }); // Register the layer with our parent.

  shared.useOnce(function () {
    if (parent) {
      parent.layers.add(layer);
      parent.update();
      return function () {
        parent.layers["delete"](layer);
        parent.update();
      };
    }
  });
  var translate3d = ctrl.springs.translate.to(horizontal ? function (x) {
    return "translate3d(" + x + "px,0,0)";
  } : function (y) {
    return "translate3d(0," + y + "px,0)";
  });
  return /*#__PURE__*/React.createElement(web.a.div, _extends({}, rest, {
    style: _extends((_extends2 = {
      position: 'absolute',
      backgroundSize: 'auto',
      backgroundRepeat: 'no-repeat',
      willChange: 'transform'
    }, _extends2[horizontal ? 'height' : 'width'] = '100%', _extends2[horizontal ? 'width' : 'height'] = ctrl.springs.space, _extends2.WebkitTransform = translate3d, _extends2.msTransform = translate3d, _extends2.transform = translate3d, _extends2), rest.style)
  }));
}));
var Parallax = React.memo(React.forwardRef(function (props, ref) {
  var _extends3;

  var _useState = React.useState(false),
      ready = _useState[0],
      setReady = _useState[1];

  var pages = props.pages,
      innerStyle = props.innerStyle,
      _props$config = props.config,
      config = _props$config === void 0 ? web.config.slow : _props$config,
      _props$enabled = props.enabled,
      enabled = _props$enabled === void 0 ? true : _props$enabled,
      _props$horizontal = props.horizontal,
      horizontal = _props$horizontal === void 0 ? false : _props$horizontal,
      rest = _objectWithoutPropertiesLoose(props, ["pages", "innerStyle", "config", "enabled", "horizontal"]);

  var state = useMemoOne.useMemoOne(function () {
    return {
      config: config,
      busy: false,
      space: 0,
      current: 0,
      offset: 0,
      controller: new web.Controller({
        scroll: 0
      }),
      layers: new Set(),
      update: function (_update) {
        function update() {
          return _update.apply(this, arguments);
        }

        update.toString = function () {
          return _update.toString();
        };

        return update;
      }(function () {
        return update();
      }),
      scrollTo: function (_scrollTo) {
        function scrollTo(_x) {
          return _scrollTo.apply(this, arguments);
        }

        scrollTo.toString = function () {
          return _scrollTo.toString();
        };

        return scrollTo;
      }(function (offset) {
        return scrollTo(offset);
      }),
      stop: function stop() {
        return state.controller.stop();
      }
    };
  }, []);
  React.useEffect(function () {
    state.config = config;
  }, [config]);
  React.useImperativeHandle(ref, function () {
    return state;
  });
  var containerRef = React.useRef();
  var contentRef = React.useRef();

  var update = function update() {
    var container = containerRef.current;
    if (!container) return;
    var spaceProp = horizontal ? 'clientWidth' : 'clientHeight';
    state.space = container[spaceProp];
    var scrollType = getScrollType(horizontal);

    if (enabled) {
      state.current = container[scrollType];
    } else {
      container[scrollType] = state.current = state.offset * state.space;
    }

    var content = contentRef.current;

    if (content) {
      var sizeProp = horizontal ? 'width' : 'height';
      content.style[sizeProp] = state.space * pages + "px";
    }

    state.layers.forEach(function (layer) {
      layer.setHeight(state.space, true);
      layer.setPosition(state.space, state.current, true);
    });
  };

  var scrollTo = function scrollTo(offset) {
    var container = containerRef.current;
    var scrollType = getScrollType(horizontal);
    state.offset = offset;
    state.controller.stop().start({
      scroll: offset * state.space,
      config: config,
      onChange: function onChange(_ref2) {
        var scroll = _ref2.scroll;
        container[scrollType] = scroll;
      }
    });
  };

  var onScroll = function onScroll(event) {
    if (!state.busy) {
      state.busy = true;
      state.current = event.target[getScrollType(horizontal)];
      globals.frameLoop.onFrame(function () {
        state.layers.forEach(function (layer) {
          return layer.setPosition(state.space, state.current);
        });
        state.busy = false;
      });
    }
  };

  React.useEffect(function () {
    return state.update();
  });
  shared.useOnce(function () {
    setReady(true);

    var onResize = function onResize() {
      var update = function update() {
        return state.update();
      };

      globals.frameLoop.onFrame(update);
      setTimeout(update, 150); // Some browsers don't fire on maximize!
    };

    window.addEventListener('resize', onResize, false);
    return function () {
      return window.removeEventListener('resize', onResize, false);
    };
  });
  var overflow = enabled ? 'scroll' : 'hidden';
  return /*#__PURE__*/React.createElement(web.a.div, _extends({}, rest, {
    ref: containerRef,
    onScroll: onScroll,
    onWheel: enabled ? state.stop : undefined,
    onTouchStart: enabled ? state.stop : undefined,
    style: _extends({
      position: 'absolute',
      width: '100%',
      height: '100%',
      overflow: overflow,
      overflowY: horizontal ? 'hidden' : overflow,
      overflowX: horizontal ? overflow : 'hidden',
      WebkitOverflowScrolling: 'touch',
      WebkitTransform: START_TRANSLATE,
      msTransform: START_TRANSLATE,
      transform: START_TRANSLATE_3D
    }, rest.style)
  }), ready && /*#__PURE__*/React.createElement(web.a.div, {
    ref: contentRef,
    style: _extends((_extends3 = {
      overflow: 'hidden',
      position: 'absolute'
    }, _extends3[horizontal ? 'height' : 'width'] = '100%', _extends3[horizontal ? 'width' : 'height'] = state.space * pages, _extends3.WebkitTransform = START_TRANSLATE, _extends3.msTransform = START_TRANSLATE, _extends3.transform = START_TRANSLATE_3D, _extends3), props.innerStyle)
  }, /*#__PURE__*/React.createElement(ParentContext.Provider, {
    value: state
  }, rest.children)));
}));

exports.Parallax = Parallax;
exports.ParallaxLayer = ParallaxLayer;
//# sourceMappingURL=index.cjs.js.map
